<?xml version="1.0" encoding="utf-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_lite.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_lite.rng" type="application/xml"
	schematypens="http://purl.oclc.org/dsdl/schematron"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>TEI ガイドラインとスタイルシートをビルドしてテストする</title>
        <author>Hugh Cayless</author>
      </titleStmt>
      <publicationStmt>
        <publisher>TEI 技術評議会</publisher>
        <date>2016</date>
      </publicationStmt>
      <sourceDesc>
        <p>Born digital document.</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <div>
        <head>ガイドラインとスタイルシートをビルドしてテストする方法</head>
        <p>ガイドラインとスタイルシートを色々とビルドしてテストするための環境を用意するのは、Ubuntu などの Debian Linux では比較的簡単です。しかし Mac OS X や Windows といったそれ以外のシステムでは、かなり手の込んだ作業が必要になります。TEI あるいは Stylesheet リポジトリに変更が加えられると、TEI Jenkins サーバでさまざまなビルドが行われますが、自分のマシンでテストを実行した方がよいかもしれません。というのも、おそらくその方が実行も速いでしょうし、問題が見つかったときに Jenkins からメールが届くのを待っている時間も節約してくれるからです。それだけでなく、作業用ブランチでの変更については Jenkins はまったく関知しませんし、かといって dev ブランチにマージした後で大量のバグを直すハメになるのは避けたいところです。ですから自分でまず作業結果をチェックするのはとても有益でしょう。</p>
        <p>自分用の開発・テスト環境を構築するための第一歩は、TEI および Stylesheet リポジトリのコピーを入手することです。これらは <ptr target="https://github.com/TEIC/TEI"/> と <ptr target="https://github.com/TEIC/Stylesheets"/> からそれぞれ入手することができます。ここから先の手順説明はすべて、少なくともある程度コマンドラインでの作業に慣れているものと仮定しています。そうでないならばこれが学ぶよい機会かもしれません。Mac に偏ったチュートリアルですが “<ref target="https://www.learnenough.com/command-line-tutorial">Learn Enough Command Line to Be Dangerous</ref>” があります。Windows 10 ユーザなら “<ref target="http://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/">How to Install and Use the Linux Bash Shell on Windows 10</ref>” で Bash シェルのインストール方法とその使い方の基本を学ぶことができるでしょう。さてターミナルのウィンドウを開いたら、次のコマンドで TEI のリポジトリを複製することができます。<lb/><code>git clone git@github.com:TEIC/TEI.git</code>  <lb/><code>git clone git@github.com:TEIC/Stylesheets.git</code></p>
        <p>これらのリポジトリは同じディレクトリに保存するのがおそらくはいいでしょう。私は <code>/Users/hcayless/Development/TEIC</code> という名前のディレクトリに保存しています。この先わかるでしょうが、Mac か Windows ならユーザディレクトリのどこかがいいでしょう。Ubuntu かその他の Linux を使用しているなら、好きなところでいいです。すでに TEI および Stylesheets リポジトリの作業用コピーを用意していて、そこで行われた変更を GitHub リポジトリに送信して公開する前にテストしたいものと仮定しましょう。TEI では環境構築済みのテスト用 Docker を提供しています。まずは Docker の実行環境を入手してください。Mac なら <ptr target="https://www.docker.com/products/docker#/mac"/> で、Windowsなら <ptr target="https://www.docker.com/products/docker#/windows"/> で、Linuxなら <ptr target="https://www.docker.com/products/docker#/linux"/> で入手することができます。Docker をインストールしたら、次のコマンドを実行して、環境構築済みイメージファイルのコピーを入手してください。<lb/><code>docker pull teic/teidev-docker</code> <lb/></p>
        <p>これでテスト環境を実行する準備が整いました。Docker のための情報があと二、三必要です。リポジトリのある場所と、タイムゾーンです。タイムゾーンは <ref target="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">Wikipedia</ref> で調べることができます。これが必要になるのは、Docker コンテナのタイムゾーンの初期設定が UTC だからです。これはたまたま実際に UTC 時間を使用してた場合を除いて、ビルドの際に奇妙な警告を引き起こすことになります。というのも、コンピュータのローカル時刻と、コンテナの中の設定が一致しないからです。リポジトリを格納しているディレクトリは、コンテナの中のディレクトリに対応づけられます（これがリポジトリを1箇所にかためておく方がやりやすい理由です）。テストコンテナを実行するには次のようなコマンドを使用します。<lb/><code>docker run --name tei -v /Users/hcayless/Development/TEIC:/tei -it -e TZ=America/New_York
            teic/teidev-docker</code> <lb/> これにより、"tei" と名付けられたコンテナのルートディレクトリに、Bash シェルを使ってログインします。TEI と Stylesheets リポジトリを複製したローカルファイルシステム上のディレクトリは、コンテナの <code>/tei</code> ディレクトリに対応づけられます（これが上記のコマンドで <code>-v</code> の後に続く部分の意味です）。その後 <code>cd tei</code> を実行し、次に <code>ls</code> を行うと、上で複製したリポジトリが表示されます。もう一つすることがあります。それは、ガイドラインをビルドするプロセスに、Stylesheets リポジトリの複製がどこにあるかを教えることです。<code>TEI/P5</code> ディレクトリに <code>local.mk</code> ファイルを追加することによって、これを行います。そこで（ <code>/tei</code> ディレクトリから）<code>cd TEI/P5</code> を行ってから、<code>echo "XSL=/tei/Stylesheets" &gt; local.mk</code> を実行します。これでビルドをすることができるようになりました。それだけでなく、通常の環境で Guidelines と Stylesheets リポジトリの作業を行ってから、それを Docker でテストすることもできます。上記の Docker 作成コマンドで、コンテナに "tei" という名前をつけましたので、これを使って後から Docker 環境に戻ってくることができます。この環境は Bash 端末を実行しているので、コマンドプロンプトで <code>exit</code> を入力することにより、この環境から抜けることができ、これによりコンテナも停止します。再起動は <code>docker start -ai tei</code> というコマンドで可能です。これにより前回コンテナを停止した時の状態から再度コンテナが起動され、端末が接続されます。<code>docker start -ai tei</code> の代わりに、<code>teidocker</code> といった単純な別名のコマンドを作りたくなるかもしれませんね。</p>
        <p>To build the HTML version of the Guidelines, for example, you can run (in
            <code>/tei/TEI/P5</code>) <code>make html-web</code>, and after the process finishes,
          you’ll have a directory called “Guidelines-web” in your P5 directory. Outside your Docker
          shell, you can browse to this folder, find the index.html file, and open it in a browser.
          “Make” is a program typically used for compiling programs, but it’s also very useful as a 
          kind of generic batch scripting tool, which is how it’s being used here. In the
          Guidelines, you’ll typically want to run Make inside the <code>P5/</code> directory and in
          the Stylesheets, you’ll want to run it at the top of the repo (in
          <code>Stylesheets/</code>. You can also run Make in any directory that contains a
          <code>Makefile</code>. Note that the targets may vary. Running <code>make</code> inside
          <code>Stylesheets/Test</code> is pretty much the same as running <code>make test</code>
          one level up. You can also run individual test targets if there’s a particular set 
          of tests you want to troubleshoot (e.g. <code>make test-oddity</code> in
          <code>Stylesheets/Test</code> to test ODD-conversion methods). The targets are all defined
          in the <code>Makefile</code>s.</p>
        <p>The <ref target="http://www.tei-c.org/Guidelines/P5/get.xml">Using the TEI GitHub
          Repository</ref> document has more detail on all the processes you can run, and very
          meager information on how to get set up to run them—but you just bypassed all that.
          Besides the <code>make</code> targets listed there, both the TEI and Stylesheets repos
          have <code>make test</code> targets which get run by Jenkins when you push to GitHub.
          These are both good ways to check your code before pushing. Make does lots of things when
          you run any of these targets, but all of them should finish with a “BUILD SUCCESSFUL”
          message. If there’s a problem, you’ll get a failure message, hopefully with some
          indication of what went wrong. If you’ve run a build target, you probably want to run a
            <code>make clean</code> before doing it again to make sure files that were generated
          during the last run don’t interfere with your next build (Make tries not to repeat itself,
          so if it finds existing build artifacts, it won’t rebuild them). Targets can be put
          together, so you can do <code>make clean test</code>, and it will clean things up before
          running the test target.</p>
        <p>When you run the tests and other build targets, you’ll see masses of text written out,
          most of which can be ignored. If one of the processes errors out, Make should stop
          running, so the last thing in your terminal should tell you what happened. This may not be
          a very useful message, so you might need to isolate the command that Make ran and run it
          yourself to see the error messages. In the Stylesheets, errors are often in the form of
          differences between the expected output of certain tests and the actual output. Test
          failures here aren’t necessarily errors—if you changed something to do with ODD
          compilation or schema generation, your new output might be correct but different from the
          old. When this happens, you can copy the new output from the <code>Test/</code> directory
          into <code>Test/expected-results</code>. You’ll want to be a bit careful that your new
          output is actually correct, of course, because now the test will pass even if it’s not
          really working, because all it’s checking is whether the test output is the same as what
          it expects.</p>
        <p>Good luck and happy testing!</p>
      </div>
    </body>
  </text>
</TEI>
